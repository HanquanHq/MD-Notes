# 第二章 进程管理 - 处理机调度

### 调度的三个层次

<img src="images/image-20201103111302110.png" alt="image-20201103111302110" style="zoom: 50%;" />

#### 高级调度（作业调度）

> 作业：一个具体的任务
> 用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）
>
> 简化理解：好几个程序需要启动，到底先启动哪个

按一定的原则从**外存的作业后备队列中挑选一个作业调入内存**，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

#### 中级调度（内存调度）

> 内存不够时，将某些进程的数据调出到外存。等内存空闲 / 进程需要运行时，再重新调入内存。
> 暂时调到外存等待的进程为挂起状态。被挂起的进程PCB会被组织成挂起队列

按照某种策略决定**将哪个处于挂起状态的进程重新调入内存**。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

#### 低级调度（进程调度/处理机调度）频率最高

按照某种策略**从就绪队列中选取一个进程**，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。



### 进程的七状态模型

暂时调到外存等待的进程状态为挂起状态（挂起态，suspend），挂起态又可以进一步细分为 **就绪挂起**、**阻塞挂起** 两种状态

##### 五状态模型 -> 七状态模型

<img src="images/image-20201103110757865.png" alt="image-20201103110757865" style="zoom: 60%;" />



### 进程调度的时机

##### 1、当前运行的进程主动放弃处理机

- 进程正常终止
- 运行过程中发生异常而终止
- 进程主动请求阻塞（如等待I/O）

##### 2、当前运行的进程被动放弃处理机

- 分给进程的时间片用完
- 有更紧急的事需要处理（如I/O中断）
- 有更高优先级的进程进入就绪队列

##### 补充：不能进行进程调度与切换的情况

1. 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
2. 进程在操作系统内核程序临界区中。
3. 原语。原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）



### 进程调度的方式

#### 非抢占式

只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

#### 抢占方式

当一个进程正在处理机上执行时，如果有更重要的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要的那个进程。



### 调度算法的评价指标

由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作

**CPU利用率：指CPU “忙碌”的时间占总时间的比例。**

- 利用率 = 忙碌的时间 / 总时间

**系统吞吐量：单位时间内完成作业的数量**

- 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间

**作业周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔**

> 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。
>
> 对于用户来说，更关心自己的单个作业的周转时间；对于操作系统来说，更关心系统的整体表现，
> 因此更关心所有作业周转时间的平均值

- 作业周转时间 = 作业完成时间 – 作业提交时间
- 平均周转时间 = 各作业周转时间之和 / 作业数量
- 带权周转时间 = 作业周转时间 / 作业实际运行的时间（必然 ≥ 1）
- 平均带权周转时间 = 各作业带权周转时间之和 / 作业数

**等待时间：进程/作业处于等待处理机状态时间之和。等待时间越长，用户满意度越低。**

对于**进程**来说，等待时间就是指进程建立后等待被服务的时间之和。在等待I/O期间，进程也是在被服务的，所以不计入等待时间。

对于**作业**来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

调度算法其实只会影响作业/进程的等待时间，而无法改变其被服务的时间。

**响应时间：指从用户提交请求到首次产生响应所用的时间。**

对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系
统服务、回应。



### 调度算法

#### 1、先来先服务 FIFS（FirstCome First Serve）

1. 算法思想

   主要从“公平”的角度考虑

2. 算法规则

   按照作业/进程到达的先后顺序进行服务

3. 作业调度 or 进程调度？

   用于**作业调度**时，考虑的是哪个作业先到达后备队列

   用于**进程调度**时，考虑的是哪个进程先到达就绪队列

4. 抢占 or 非抢占式？

   非抢占式

5. 优点和缺点

   优点：公平、算法实现简单
   缺点：对长作业有利，对短作业不利

6. 是否会导致饥饿

   不会

#### 2、短作业优先（SJF, Shortest Job First）

1. 算法思想

   追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间

2. 算法规则

   每次调度时，选择当前已到达、且运行时间最短的作业/进程。

3. 作业调度 or 进程调度？

   可用于作业调度 / 进程调度。用于进程调度时：**短进程优先（SPF, Shortest Process First）**算法

4. 抢占 or 非抢占式？

   SJF / SPF 是非抢占式。抢占式版本：**最短剩余时间优先（SRTN, Shortest Remaining Time Next）**算法

5. 优点和缺点

   优点：“最短的”平均等待时间、平均周转时间
   缺点：不公平。对短作业有利，长作业不利。可能产生饥饿现象；作业/进程的运行时间由用户提供的，不一定真实，不一定真正做到短作业优先

6. 是否会导致饥饿

   会。如果不断有短作业到来，导致长作业饥饿 / 饿死

> 注意几个小细节：
>
> 1. 如果题目中未特别说明，所提到的“短作业/进程优先算法”**默认是非抢占式**的
>
> 2. 很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”，这个表述不严谨。之前例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。
>
>    应该加上一个条件“在**所有进程同时可运行**时，采用SJF调度算法的平均等待时间、平均周转时间最少”；或者“在**所有进程都几乎同时到达**时，采用SJF调度算法的平均等待时间、平均周转时间最少”；
>
>    如不加上述前提条件，应该说“**抢占式的**短作业/进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”
>
> 3. 虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间
>
> 4. 如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项



#### 3、高响应比优先（HRRN, Highest Response Ratio Next）

1. 算法思想

   要综合考虑作业/进程的等待时间和要求服务的时间

2. 算法规则

   在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程，上处理机。

   > 响应比 = (等待时间+要求服务时间) / 要求服务时间

3. 作业调度 or 进程调度？

   均可

4. 抢占 or 非抢占式？

   非抢占式。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。

5. 优点和缺点

   综合考虑了等待时间和运行时间（要求服务时间）。

   **等待时间相同**时，要求服务时间短的优先（SJF 的优点）。

   **要求服务时间相同**时，等待时间长的优先（FCFS 的优点）

   **等待时间越来越久，响应比会越来越大**，从而避免了长作业饥饿的问题。

6. 是否会导致饥饿

   不会



###### 以下三种算法适合用于交互式系统，更注重系统的响应时间、公平性、平衡性等指标。

#### 4、时间片轮转（RR, Round-Robin）

1. 算法思想

   公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应

2. 算法规则

   按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。

   随着分时操作系统的出现而出现，更注重“响应时间”。

3. 作业调度 or 进程调度？

   进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）

4. 抢占 or 非抢占式？

   抢占式。

   由时钟装置发出时钟中断来通知CPU时间片已到。进程未能在时间片内运行完，会被剥夺处理机使用权。

5. 优点和缺点

   **优点**：公平；响应快，适用于分时操作系统；
   **缺点**：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。

6. 是否会导致饥饿

   不会



#### 5、优先级调度算法

1. 算法思想

   随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序

2. 算法规则

   每个作业/进程有各自的 **优先级**，调度时选择 **优先级最高的作业/进程**

   > 通常来说，优先级排序：
   > 
   > 系统进程 > 用户进程
   >前台进程 > 后台进程
   > I/O密集型进程 > CPU密集型进程（计算型进程）

3. 作业调度 or 进程调度？

   均可。既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中

4. 抢占 or 非抢占式？

   抢占式、非抢占式 **都有**。

   非抢占式在 **进程主动放弃处理机** 时进行调度即可；抢占式还需在 **就绪队列变化** 时，检查是否会发生抢占。

5. 优点和缺点

   优点：用优先级区分紧急程度、重要程度，可灵活调整，适用于实时操作系统
   缺点：若不断地有高优先级进程到来，则可能导致饥饿

6. 是否会导致饥饿

   会



#### 6、多级反馈队列调度算法（UNIX使用）

1. 算法思想

   对其他调度算法的 **折中** 权衡

2. 算法规则

   <img src="images/image-20201104110318772.png" alt="image-20201104110318772" style="zoom:77%;" />

   1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
   2. 新进程到达时**先进入第1级队列**，按FCFS原则排队等待被分配时间片，若**用完时间片进程还未结束**，则进程**进入下一级队列**队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
   3. 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片

3. 作业调度 or 进程调度？

   进程调度

4. 抢占 or 非抢占式？

   **抢占**。在k 级队列的进程运行过程中，若更上级的队列（1 ~ k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。

5. 优点和缺点

   对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）

6. 是否会导致饥饿

   会，考虑不断有短时间的进程到来的情况。