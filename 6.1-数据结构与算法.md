---
typora-copy-images-to: /images/
---

# 数据结构与算法

### 数据结构算法常见面试考题

部分摘自 https://blog.csdn.net/u012414189/article/details/83832161 



#### 为什么有完全二叉树的存在？

因为可以用数组存



#### Java 按位异或小技巧

```java
System.out.println(1 ^ 2 ^ 3 ^ 4 ^ 2 ^ 3 ^ 1);//使用按位异或，找到数组中唯一不重复的项
```



#### Top K 问题（可以采取的方法有哪些，各自优点？）

1.将输入内容（假设用数组存放）进行完全排序，从中选出排在前K的元素即为所求。有了这个思路，我们可以选择相应的排序算法进行处理，目前来看快速排序，堆排序和归并排序都能达到O(nlogn)的时间复杂度。

2.对输入内容进行部分排序，即只对前K大的元素进行排序（这K个元素即为所求）。此时我们可以选择冒泡排序或选择排序进行处理，即每次冒泡（选择）都能找到所求的一个元素。这类策略的时间复杂度是O(Kn)。

3.对输入内容不进行排序，显而易见，这种策略将会有更好的性能开销。我们此时可以选择两种策略进行处理：

用一个桶来装前k个数，桶里面可以按照最小堆来维护
a)利用最小堆维护一个大小为K的数组，目前该小根堆中的元素是排名前K的数，其中根是最小的数。此后，每次从原数组中取一个元素与根进行比较，如大于根的元素，则将根元素替换并进行堆调整（下沉），即保证小根堆中的元素仍然是排名前K的数，且根元素仍然最小；否则不予处理，取下一个数组元素继续该过程。该算法的时间复杂度是O(nlogK)，一般来说企业中都采用该策略处理top-K问题，因为该算法不需要一次将原数组中的内容全部加载到内存中，而这正是海量数据处理必然会面临的一个关卡。

b)利用快速排序的分划函数找到分划位置K，则其前面的内容即为所求。该算法是一种非常有效的处理方式，时间复杂度是O(n)（证明可以参考算法导论书籍）。对于能一次加载到内存中的数组，该策略非常优秀。



## 树

### 二叉树

#### 满二叉树

一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是(2^k) -1，则它就是满二叉树。）

<img src="images/1468919-20191103194220076-925294362.png" alt="img" style="zoom:67%;" />

#### 完全二叉树

若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都**连续集中在最左边**，这就是完全二叉树。

<img src="images/1468919-20191103194739538-2034251878.png" alt="img" style="zoom:60%;" />

#### 平衡二叉树

它或者是一颗空树，或它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

<img src="images/1468919-20191103195149869-1317786481.png" alt="img" style="zoom:67%;" />



#### 堆

堆，是具有以下性质的 **完全二叉树**

- 每个结点的值都大于或等于其左右孩子结点的值，称为 **大顶堆**
- 每个结点的值都小于或等于其左右孩子结点的值，称为 **小顶堆**



#### 二叉查找树（BST）

二叉查找树的特点：

- 若任意节点的左子树不空，则左子树上所有结点的 值均小于它的根结点的值
- 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值
- 任意节点的左、右子树也分别为二叉查找树
- 没有键值相等的节点（no duplicate nodes）



#### 平衡二叉树（Self-balancing binary search tree）

平衡二叉树（平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等）



#### 红黑树

红黑树特点:

- 每个节点非红即黑；
- 根节点总是黑色的；
  每个叶子节点都是黑色的空节点（NIL节点）；
- 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
- 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

##### 红黑树的应用：

TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。

##### 为什么要用红黑树？

简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 漫画：什么是红黑树？（也介绍到了二叉查找树，非常推荐）

##### 推荐文章：

- [漫画：什么是红黑树？](https://juejin.im/post/5a27c6946fb9a04509096248#comment)（也介绍到了二叉查找树，非常推荐）
- [寻找红黑树的操作手册](http://dandanlove.com/2018/03/18/red-black-tree/)（文章排版以及思路真的不错）
- [红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)（美团点评技术团队）



#### B，B+，B* 树

二叉树学习笔记之B树、B+树、B*树

B树是一种平衡的多路查找（又称排序）树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)

B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。

B+树支持range-query（区间查询）非常方便，而B树不支持。这是数据库选用B+树的最主要原因。

`B*`树 是B+树的变体，B*树分配新结点的概率比B+树要低，空间使用率更高；



#### LSM 树

[HBase] LSM 树 VS B+树

B+树最大的性能问题是会产生大量的随机IO

为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。

LSM树由来、设计思想以及应用到HBase的索引



