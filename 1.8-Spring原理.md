---
typora-copy-images-to: /images/
---



# Spring 原理

### Spring IOC 常用注解

#### 使用注解的方式将 bean 注册到 IOC 容器中

这四个注解写在类上面的时候，都可以完成注册bean 的功能，但是这些规定并不是spring识别的依据

在spring运行过程中，不会对这4个注解做任何区分，看起来都是一样的，都会完成bean的注册功能

在实际开发中，最好能分清楚，提高代码的可读性

##### @Component

组件，理论上可以在任何位置添加，在扫描的时候都会完成 bean 的注册。最偷懒的方式，就是给所有需要注册的 bean 上面添加 @Component 注解

##### @Controller

放在控制层，用来接收用户的请求

##### @Service

放在业务逻辑层

##### @Repository

放在 dao 数据访问层

##### @ComponentScan

Spring容器在运行的时候，怎么知道从哪个包扫描呢？

所以，在使用上述注解的时候，需要 xml 文件中配置context:conponent-scan，并且导入 context 命名空间

```java
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
PersonController personController = context.getBean("personController", PersonController.class)
```



##### 使用注解的时候，并没有定义 bean 的 id 和 class，那么 spring 是怎么识别的呢？

是把当前类的名称首字母小写来识别的。需要的话，你可以在注解中使用value=修改名称，一般不会去修改。





#### 使用 @Autowired 进行自动注入

首先，bean 已经被注册到Spring IOC 容器中了，但是如果不使用 Autowired 的话，没有被注入到对象中。

@AutoWired 是通过反射的方式注入的。

##### Autowired 是根据什么依据来装配的呢？by name？by type？

当使用AutoWired注解的时候，自动装配的时候是根据类型实现的。

1. 如果只找到一个，则直接进行赋值，
2. 如果没有找到，则直接抛出异常，
3. 如果找到多个，那么会按照变量名作为id继续匹配,
   1. 匹配上直接进行装配
   2. 如果匹配不上则直接报异常

还可以使用@Qualifier注解来指定id的名称，让spring不要使用变量名,当使用@Qualifier注解的时候也会有两种情况：

1. 找到，则直接装配
2. 找不到，就会报错



##### @AutoWired可以进行定义在方法上

```java
@Controller
public class PersonController {
     /**
     * 当方法上有@AutoWired注解时：
     *  1、此方法在bean创建的时候会自动调用
     *  2、这个方法的每一个参数都会自动注入值
     * @param personDao
     */
    @Autowired
    public void test(PersonDao personDao){
        System.out.println("此方法被调用:"+personDao);
    }
```



#### 自动装配的注解@AutoWired，@Resource 区别

在使用自动装配的时候，出了可以使用@AutoWired注解之外，还可以使用@Resource注解，你需要知道这两个注解的区别。

1. @AutoWired:是spring中提供的注解，

   @Resource:是jdk中定义的注解，依靠的是java的标准

2. @AutoWired默认是按照类型进行装配，默认情况下要求依赖的对象必须存在

   @Resource默认是按照名字进行匹配的，同时可以指定name属性

3. @AutoWired只适合spring框架，而@Resource扩展性更好



#### 泛型依赖注入

