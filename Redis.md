# Redis

### 内存模型

- epoll
  - Nginx也用了epoll
  - fd
  - 红黑树

<img src="C:\Users\Bug\Desktop\大总结\image-20200625011727690.png" alt="image-20200625011727690" style="zoom:50%;" />

- 零拷贝

  - sendfile

  - mmap

    - epoll源码没有用到mmap，是redis用到了mmap

    - 理解为：我们使用 epoll 的时候要注意用 mmap 辅助，来避免 read/write 多一次拷贝，而非系统内核帮你维护了 mmap

    - 编译器将 epoll_create 编译为了 int 80 中断等一系列汇编指令，交给CPU就行了。C代码中虽然是显式调用 epoll_create ，但C翻译成汇编的时候就翻译成了相应的0x80中断以及相关指令的

      

### 数据类型

- string
  - bitmap：可以做布隆过滤器
- list
- hashmap
- set
- sorted_set（zsest）
  - 排序的实现：跳跃表



### 使用

- 管道

  ```shell
  (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
  ```

  - 只用了一个命令的开销时间
  - 服务器将被迫回复一个队列答复

- 发布/订阅 pubsub

  - 发送者 `publish test1 hello`
  - 订阅者 `subscribe test1`
  - 场景：聊天室，启动多个 redis 去接收订阅消息
    - redis1：将消息实时推送给用户
    - redis2：存入 zset，用来取某个时间窗口的历史消息
    - redis3：启一个 service ，将最新消息推给 kafka，然后异步存入db

- 事务

  - 无论谁先开启事务，`exec`命令先到达的client，事务先被执行
  - watch 某个 key，如果发生更改，事务不执行

- 布隆过滤器

  - RedisBloom模块
  - 用**小空间**解决**大量数据匹配**，避免缓存穿透
  - 有一定的误判率

  布隆过滤器升级版

  - Counting Bloom Filter
  - 布谷鸟过滤器



### 持久化

#### RDB

```
save 900 1
save 300 10
save 60 10000

dbfilename dump.rdb
dir /var/lib/redis/6379
```

- 时点性
- save，阻塞的，比如关机维护
- bgsave，后台的，fork子进程

#### AOF

```
appendonly yes
appendfilename "appendonly.aof"

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

appendfsync always
appendfsync everysec
appendfsync no
```

- 将写操作记录到文件中
- 丢失数据少
- 可以和 RDB 同时开启
  - 4.0 以前，重写 AOF 时，删除抵消的命令，合并重复的命令
  - 4.0 以后，重写 AOF 时，将老的数据 RDB 到 AOF 文件中，再将增量数据以指令的方式 append 到 AOF 文件中





### 缓存常见问题

#### 缓存击穿

作为缓存，受到内存大小限制，可能：

- key 超过了过期时间
- key 被 LRU LFU 清掉了

因为某些 key 不在 redis 里面了，大量并发来找这个 key 的时候，这时候客户端去直接请求数据库，这就是**击穿**。

这个问题怎么解决？
只要发现某个key不存在，就让所有对这个key的请求去抢一把锁。也就是说，
让第一个找key的请求，执行一个setnx，类似于放一把锁。只有获得锁的人才能去数据库查，其他的请求让它们失败，sleep等待几秒钟之后，重新去 redis 取数据。

这会存在一个问题：
1、如果第一个拿到锁的人挂了，别人也拿不到锁，这样就死锁了。可以设置锁的过期时间来避免这个问题。
2、由于我设置了过期时间，可能会发生这样的情况：拿到锁的人没挂，但是可能由于网络拥塞或者数据库拥塞，锁超时了，又有一个人拿到这个锁，又去数据库取，更加拥塞了。
针对这个问题，可以开启多个线程，一个线程去库里取数据，另一个线程去给锁的超时时间延长。这样会让代码逻辑变得复杂。
3、像上面这样，你自己去实现分布式协调很麻烦。因此我们引入Zokeeper，这个以后再讲~

#### 缓存穿透

从业务接收查询的，是你系统里面根本不存在的数据。这就是缓存穿透。

怎么解决？使用布隆过滤器

- 你可以在客户端中包含布隆过滤器的算法
- 你可以在客户端只包含算法，在redis中存放bitmap
- 你可以直接在redis中集成布隆模块：RedisBloom模块

**布隆过滤器的缺点**

只能增加，不能删除，如果你的业务删除了数据库中的某条数据，无法在布隆过滤器中删除这个key

**解决方式**

你可以使用布谷鸟过滤器等其他支持删除操作的过滤器，或者设置一个空 key

#### 缓存雪崩

和击穿有些类似，都是后面有数据的情况。

- 大量 key 同时失效，间接造成大量的访问到达 DB

怎么解决？要考虑两种情况：

1、每天都要更新数据的情况，例如每天零点要刷新缓存。这时候可以依赖击穿的解决方案。或者在业务层加一个小延时：判断如果是零点就延时，随机sleep几秒，这样不会把流量一大波流量同时放过来。
对于能够提前预知的时点数据，比如京东双11的页面样式、图片等，可以提前推到客户端本地，到双11零点的时候直接切换即可。

2、与时点性无关（并不需要在某个时间刷新缓存）的话，可以设置随机过期时间。

#### 缓存一致性（双写问题）



### Redis 集群

单机、单节点、单实例存在的问题

- 单点故障
- 容量有限
- 单机压力过大

单机单点问题的解决方式：AKF

#### AKF拆分原则

<img src="C:\Users\Bug\Desktop\大总结\akf.png" alt="akf" style="zoom:44%;" />

- X轴：可以是Redis实例的副本，数据库的副本等
  - 读写分离，增加备用性，**解决单点故障** 问题
  - 全量镜像，**不能解决容量有限 **的问题
- Y轴：按业务拆分，数据分开存储，客户端按照业务指定查询哪个库
  - **解决容量有限** 的问题
- Z轴：在按照不同业务拆分的前提下，将同一个业务将数据再拆分，存到不同的库中
  - 数据量足够小，更易发挥单机性能

#### AKF存在的问题：CAP定理

- 一致性（Consistency）：分布式系统中的所有数据备份，在同一时刻是否同样的值
- 可用性（Availability）：集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求
- 分区容忍性（Partition tolerance）：是否能够容忍发生网络分区，对外表现出数据的不一致
  - 例如，向注册中心集群注册50台tomcat，有的仅成功注册了40台，不影响使用，可容忍

#### 集群一般使用奇数台

当存活节点过半的时候，就可以解决容错问题，正常提供服务

为什么是奇数台？你看，3个节点4个节点都最多允许1个节点挂掉，但是：

- 4台服务器成本高于3台服务器成本
- 不管你是4节点还是3个节点，都只允许挂1个，风险是一样的

#### Sentinel 哨兵

- 监控
- 提醒
- 自动故障迁移
  - 流言协议：主服务器是否下线
  - 投票协议：重新选主，故障迁移





