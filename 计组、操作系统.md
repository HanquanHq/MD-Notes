# 计组、操作系统

汇编和操作系统代码，又是不同层面的东西

汇编是针对CPU编程。系统内核方法，是针对操作系统编程。



### 进程、线程

#### 线程

- 线程是在进程中活动的对象
- 内核调度的对象是 **线程**，而不是 进程
- Linux 把所有的线程都当做进程来实现，线程仅仅被视为一个与其他进程共享某些资源的进程。

#### 进程

- 进程 是处于执行期的程序以及相关资源的总称
- 所有的进程都是 PID 为 1 的 init 进程的后代
- 内核把进程的列表放在任务队列  task list 中，链表中的每一项都是 **进程描述符**
  - 进程描述符包含：它打开的文件、进程的地址空间、挂起的信号、进程的状态等
- 进程状态
  - 运行：进程是可执行的
  - 可中断：正在睡眠，等待某些条件的达成，可以因为收到信号而提前被唤醒
  - 不可中断：即使收到信号，也不会被唤醒
  - 被其他进程跟踪：例如通过 ptrace 对调试程序进行跟踪
  - 停止：进程没有投入运行，也不能投入运行
- **进程的创建**
  - Linux 中，父进程通过 `fork()` 创建子进程，Linux 的 `fork()` 使用 **写时拷贝** 页实现
- **进程的调度**
  - Linux 使用 CFS（完全公平调度）
    - 确保给每个进程公平的 **处理器使用比**
    - 用 **红黑树** 维护 **可运行进程队列**，每次运行红黑树中 **最左边叶子结点** 代表的进程



### 系统调用

**系统调用** 是用户空间访问内核的唯一手段，除 **异常** 和 **陷入** 外，它是内核的唯一合法入口。

系统调用表及源码链接 https://filippo.io/linux-syscall-table/

- Linux 的系统调用，作为 C 库的一部分提供
- **用户空间进程** 用 **系统调用号** 来指明执行哪个系统调用。进行系统调用的步骤：
  1. 用户空间把 **系统调用号** 放入 eax 寄存器中，参数放在另外的寄存器中
  2. `int $0x80` 触发软中断，系统切换到内核态，执行 128 号异常处理程序，即 `system_call()` 系统调用处理程序
  3. `system_call()` 运行，从 eax 寄存器中得到 **系统调用号**，执行相应的系统调用
  4. 内核在执行系统调用的时候，处于 **进程上下文**。在进程上下文中，内核 **可以休眠**，并且 **可以被抢占**
  5. **系统调用返回** 的时候，`system_call()` 负责 **切换到用户空间**，并让用户进程继续执行下去



### 用户态、内核态

##### mmap

mmap将 **用户的线性地址空间** 直接映射到了 **内核的pagecache地址**，如果是脏的需要写的话，依然受pagecache 的影响，才能最终刷写到磁盘中去。



### VFS

Virtual Filesystem Switch，虚拟文件系统，是一个目录树。树上不同的节点可以映射到物理的文件地址，可以挂载。

相当于一个解耦层，在具体的文件系统之上抽象的一层，为能够给各种文件系统提供一个通用的接口，使上层的应用程序能够使用通用的接口访问不同文件系统、不同的驱动。

##### 硬链接、软链接

- 硬链接
  - 两个变量名指向了同一个物理位置
  - 如果删掉了其中一个文件，另外一方还能找到这个文件。相当于只是删除了一个引用。
- 软链接
  - 软链接是两个独立的文件。
  - 如果删除原有的`msb.txt`，则`xxoo.txt`找不到链接了，会标红报错。
- 共性
  - 无论是硬链接还是软连接，如果修改任意一方，另外一个文件也会看到这个变化。

##### 文件描述符 fd

任何程序都有：0 标准输入，1 标准输出， 2 报错输出

- `lsof` 列出系统中打开的文件

  `lsof -op $$`看见当前进程的文件描述符的细节，包括偏移量、指针等等

- `/proc/$$/fd`是当前程序的所有的文件描述符



### PageCache  页缓存

PageCache  通常4K，本来是用来优化IO的性能（优先走内存），但它的缺点是刷写硬盘不及时，在突然关机或异常断电时，有丢失数据的可能

##### 为什么 Java 程序员不要使用直接 IO，而要使用 Buffered 形式的IO？

一次写一个缓冲区大小，减少调用write的次数，只不过是每一次写入的数据量比较大。减少了用户态到内核态的来回切换带来的性能损耗。

- ByteBuffer
  - `allocate`将字节数组分配到了堆上，是 **JVM堆内** 的线性地址空间
  - `allocateDirect`将字节数组分配到 **JVM的堆外** 内存中，是C语言可以直接访问的。



> 操作系统没有绝对的数据可靠性。它什么要设计 pagecache，是为了减少硬件的IO的调用，想要优先使用内存，这样能够提速。如果追求性能，就要在一致性、可靠性之间做出权衡。
>
> 从大方面来看，在现在的分布式系统当中，如果你追求数据存储的可靠性（保持缓存和磁盘的强一致，对于每一次对数据的微小改变，都要去刷写磁盘），仍然避免不了单点故障的问题。单点故障会让你为了保持强一致而耗费的能损耗一毛钱收益都没有。
>
> 这就是为什么我们使用主从复制、主备HA
> 这就是为什么 Kafka，ES 都有副本的概念，而副本是从 socket 得到的。副本又分为同步的异步的区别，这些都是后话了，我们以后再讲…