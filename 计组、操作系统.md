# 计组、操作系统

汇编和操作系统代码，又是不同层面的东西

汇编是针对CPU编程。系统内核方法，是针对操作系统编程。



### 用户态、内核态

##### mmap

mmap将用户的线性地址空间直接映射到了内核的pagecache地址，如果是脏的需要写的话，依然受pagecache的影响，才能最终刷写到磁盘中去。

### VFS

Virtual Filesystem Switch，虚拟文件系统，是一个目录树。树上不同的节点可以映射到物理的文件地址，可以挂载。

相当于一个解耦层，在具体的文件系统之上抽象的一层，为能够给各种文件系统提供一个通用的接口，使上层的应用程序能够使用通用的接口访问不同文件系统、不同的驱动。

##### 硬链接、软链接

- 硬链接
  - 两个变量名指向了同一个物理位置
  - 如果删掉了其中一个文件，另外一方还能找到这个文件。相当于只是删除了一个引用。
- 软链接
  - 软链接是两个独立的文件。
  - 如果删除原有的`msb.txt`，则`xxoo.txt`找不到链接了，会标红报错。
- 共性
  - 无论是硬链接还是软连接，如果修改任意一方，另外一个文件也会看到这个变化。

##### 文件描述符 fd

任何程序都有：0 标准输入，1 标准输出， 2 报错输出

- `lsof` 列出系统中打开的文件

  `lsof -op $$`看见当前进程的文件描述符的细节，包括偏移量、指针等等

- `/proc/$$/fd`是当前程序的所有的文件描述符



### PageCache  页缓存

PageCache  通常4K，本来是用来优化IO的性能（优先走内存），但它的缺点是刷写硬盘不及时，在突然关机或异常断电时，有丢失数据的可能

##### 为什么 Java 程序员不要使用直接 IO，而要使用 Buffered 形式的IO？

一次写一个缓冲区大小，减少调用write的次数，只不过是每一次写入的数据量比较大。减少了用户态到内核态的来回切换带来的性能损耗。

- ByteBuffer
  - `allocate`将字节数组分配到了堆上，是 **JVM堆内** 的线性地址空间
  - `allocateDirect`将字节数组分配到 **JVM的堆外** 内存中，是C语言可以直接访问的。



> 操作系统没有绝对的数据可靠性。它什么要设计pagecache，是为了减少硬件的IO的调用，想要优先使用内存，这样能够提速。如果追求性能，就要在一致性、可靠性之间做出权衡。
>
> 从大方面来看，在现在的分布式系统当中，如果你追求数据存储的可靠性（保持缓存和磁盘的强一致，对于每一次对数据的微小改变，都要去刷写磁盘），仍然避免不了单点故障的问题。单点故障会让你为了保持强一致而耗费的能损耗一毛钱收益都没有。
>
> 这就是为什么我们使用主从复制、主备HA
> 这就是为什么Kafka，ES都有副本的概念，而副本是从socket得到的。副本又分为同步的异步的区别，这些都是后话了，我们以后再讲…